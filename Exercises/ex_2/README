Bricker is an object-oriented game project developed as part of the OOP course.
The game applies key principles of object-oriented programming — encapsulation,
inheritance, and polymorphism — to design a modular and maintainable system.
It demonstrates clean software architecture combined with engaging gameplay.


Question 1:

The design I choose is based on the Strategy Pattern using Composition and Factory Design offers
significant advantages in modularity and flexability.
However, it comes with trade-offs such as increased complexity, potential performance impacts and debugging challenges.

Pros:
1.	Flexibility:
        Different bricks can be assigned unique combinations of strategies dynamically at runtime using the factory,
        allowing for a diverse range of behaviors with minimal changes.
2.	Modularity and Encapsulation:
        Each behavior is encapsulated in a separate xxxCollisionStrategy class
        that implements the CollisionStrategy interface.
        The Brick class does not need to know the details of these behaviors,
        leading to cleaner and more maintainable code.
3.	Adherence to SOLID Principles:
        Open/Closed Principle: The system is open to extension (by adding new strategies)
        but closed to modification (no need to modify existing strategies or brick logic).
        Single Responsibility Principle: Each strategy focuses on a single behavior,
        making the system easier to understand and debug.
        Although Ican have multiple behaviors, the responasbility for their creation is centered in one place.
4.	Reusability:
        Strategies can be reused for different brick types or even other game objects.
5.	Dynamic Behavior Assignment:
        The factory design allows runtime decisions on which strategies to assign to bricks,
        enabling dynamic customization of brick behaviors.

Cons
1.	Dependency on Factory Logic:
        The CollisionStrategiesFactory must correctly handle the mapping of behaviors to strategies.
        Errors or misconfigurations in the factory logic can lead to incorrect or missing behaviors.
2.	Increased Complexity:
        The strategy and factory patterns introduce multiple classes and layers of abstraction.
        This can make the codebase harder to navigate and understand, especially for new developers.
3.	Higher Memory Usage:
        Each brick maintains a list of strategy objects, which can increase memory consumption
        in games with many bricks.
4.	Potential Redundancy:
        Similar behaviors across different bricks may lead to duplication in strategy implementations.

Question 2:

Graphical Lives Display
1.	Hearts as Visual Indicators:
        The Heart class represents individual heart icons displayed on the screen.
2.	Dynamic Heart Management:
        The Lives class manages an array of heart icons (livesArr).
        When the player's life count decreases, the last heart in the array is removed from the screen and the array.
        Conversely, when a bonus life is gained, a new heart is added to the array and rendered on the screen.

Numeric Lives Display
1. A TextRenderable (textLives) is used in Lives object to show the current number of lives numerically.
   The text is updated whenever the number of lives changes.

Integration of Graphical and Numeric Displays:
1. Both the numeric counter (textLives) and the heart icons (livesArr) are synchronized
   with the Counter object (livesCounter) that tracks the player's lives.
   The update method in the Lives class ensures the visual and
   numerical displays reflect the current state of the livesCounter.

Question 3:

Iimplemented several special behaviors using the Strategy Design Pattern,
where each special behavior has its own dedicated class that implements the CollisionStrategy interface.
Each behavior is executed upon a collision with a brick by activating the appropriate collision strategy.
Each strategy Ibuilt receives a manager object.
After collision with a brick, the brick activates its behaviours,
and method onCollision in each strategy activates its corresponding method in manager.
After calling the relevant method, the manager tracks and updates the game according to the specific strategy
as mentioned in the instructions.

Question 4:

A while loop is used to iteratively add up to MAXIMAL_UNIQUE_STRATEGIES strategies.
Each iteration randomly selects a potential strategy.

When randomizedOption == DOUBLE_BEHAVIOR, the loop intentionally skips adding a new strategy during this iteration.
Instead, it increases the counterOfLeftToAddStrategies by 1,
meaning one more unique strategy will need to be added later.
If a valid strategy is created in that iteration, it is added to the
 collisionStrategiesArray,
and the counters (counterOfAddedStrategies and counterOfLeftToAddStrategies) are updated accordingly.
For the double behavior (randomizedOption == DOUBLE_BEHAVIOR), since no strategy is added,
the counterOfLeftToAddStrategies is incremented. This ensures that the loop runs an extra time
to potentially include more strategies later.

Question 5:

I have not made any changes to the API of part 1.
It should be noted that I implemented, in part 2,
the interface of the strategy by class for each strategy.
I also added additional game objects: BonusLifeHeart, ExtraPaddle, PuckBall.
Bricker is an object-oriented game project developed as part of the OOP course.
The game applies key principles of object-oriented programming — encapsulation,
inheritance, and polymorphism — to design a modular and maintainable system.
It demonstrates clean software architecture combined with engaging gameplay.


Question 1:

The design I choose is based on the Strategy Pattern using Composition and Factory Design offers
significant advantages in modularity and flexibility.
However, it comes with trade-offs such as increased complexity, potential performance impacts and debugging challenges.

Pros:
1.	Flexibility:
        Different bricks can be assigned unique combinations of strategies dynamically at runtime using the factory,
        allowing for a diverse range of behaviors with minimal changes.
2.	Modularity and Encapsulation:
        Each behavior is encapsulated in a separate xxxCollisionStrategy class
        that implements the CollisionStrategy interface.
        The Brick class does not need to know the details of these behaviors,
        leading to cleaner and more maintainable code.
3.	Adherence to SOLID Principles:
        Open/Closed Principle: The system is open to extension (by adding new strategies)
        but closed to modification (no need to modify existing strategies or brick logic).
        Single Responsibility Principle: Each strategy focuses on a single behavior,
        making the system easier to understand and debug.
        Although I can have multiple behaviors, the responsibility for their creation is centered in one place.
4.	Reusability:
        Strategies can be reused for different brick types or even other game objects.
5.	Dynamic Behavior Assignment:
        The factory design allows runtime decisions on which strategies to assign to bricks,
        enabling dynamic customization of brick behaviors.

Cons
1.	Dependency on Factory Logic:
        The CollisionStrategiesFactory must correctly handle the mapping of behaviors to strategies.
        Errors or misconfigurations in the factory logic can lead to incorrect or missing behaviors.
2.	Increased Complexity:
        The strategy and factory patterns introduce multiple classes and layers of abstraction.
        This can make the codebase harder to navigate and understand, especially for new developers.
3.	Higher Memory Usage:
        Each brick maintains a list of strategy objects, which can increase memory consumption
        in games with many bricks.
4.	Potential Redundancy:
        Similar behaviors across different bricks may lead to duplication in strategy implementations.

Question 2:

Graphical Lives Display
1.	Hearts as Visual Indicators:
        The Heart class represents individual heart icons displayed on the screen.
2.	Dynamic Heart Management:
        The Lives class manages an array of heart icons (livesArr).
        When the player's life count decreases, the last heart in the array is removed from the screen and the array.
        Conversely, when a bonus life is gained, a new heart is added to the array and rendered on the screen.

Numeric Lives Display
1. A Text Renderable (textLives) is used in Lives object to show the current number of lives numerically.
   The text is updated whenever the number of lives changes.

Integration of Graphical and Numeric Displays:
1. Both the numeric counter (textLives) and the heart icons (livesArr) are synchronized
   with the Counter object (livesCounter) that tracks the player's lives.
   The update method in the Lives class ensures the visual and
   numerical displays reflect the current state of the livesCounter.

Question 3:

Iimplemented several special behaviors using the Strategy Design Pattern,
where each special behavior has its own dedicated class that implements the CollisionStrategy interface.
Each behavior is executed upon a collision with a brick by activating the appropriate collision strategy.
Each strategy Ibuilt receives a manager object.
After collision with a brick, the brick activates its behaviours,
and method onCollision in each strategy activates its corresponding method in manager.
After calling the relevant method, the manager tracks and updates the game according to the specific strategy
as mentioned in the instructions.

Question 4:

A while loop is used to iteratively add up to MAXIMAL_UNIQUE_STRATEGIES strategies.
Each iteration randomly selects a potential strategy.

When randomizedOption == DOUBLE_BEHAVIOR, the loop intentionally skips adding a new strategy during this iteration.
Instead, it increases the counterOfLeftToAddStrategies by 1,
meaning one more unique strategy will need to be added later.
If a valid strategy is created in that iteration, it is added to the
 collisionStrategiesArray,
and the counters (counterOfAddedStrategies and counterOfLeftToAddStrategies) are updated accordingly.
For the double behavior (randomizedOption == DOUBLE_BEHAVIOR), since no strategy is added,
the counterOfLeftToAddStrategies is incremented. This ensures that the loop runs an extra time
to potentially include more strategies later.

Question 5:

I have not made any changes to the API of part 1.
It should be noted that I implemented, in part 2,
the interface of the strategy by class for each strategy.
I also added additional game objects: BonusLifeHeart, ExtraPaddle, PuckBall.
